# Critical Refund Calculation Vulnerability in ExactOutput Swaps

## Project: Injective Swap Contract

## Severity: Critical

## Category: Logic Error / Arithmetic Calculation

---

## ðŸ” Description

A critical vulnerability exists in the refund calculation logic for ExactOutput swaps in `contracts/swap/src/swap.rs`. The contract incorrectly calculates refunds using the estimated input quantity (`estimation.result_quantity`) instead of the actual required input (`required_input`) that is deducted from the user's balance. This discrepancy leads to incorrect refunds that can result in either user fund theft or contract insolvency.

## ðŸ“œ Affected Code

```rust
// contracts/swap/src/swap.rs lines 52-86
let refund_amount = if matches!(swap_quantity_mode, SwapQuantityMode::ExactOutputQuantity(..)) {
    let target_output_quantity = quantity;

    let estimation = estimate_swap_result(
        deps.as_ref(),
        &env,
        source_denom.to_owned(),
        target_denom,
        SwapQuantity::OutputQuantity(target_output_quantity),
    )?;

    let querier = InjectiveQuerier::new(&deps.querier);
    let first_market_id = steps[0].to_owned();
    let first_market = querier.query_spot_market(&first_market_id)?.market.expect("market should be available");

    let is_input_quote = first_market.quote_denom == *source_denom;

    let required_input = if is_input_quote {
        estimation.result_quantity.int() + FPDecimal::ONE  // Adds buffer for quote inputs
    } else {
        round_up_to_min_tick(estimation.result_quantity, first_market.min_quantity_tick_size)
    };

    let fp_coins: FPDecimal = coin_provided.amount.into();

    if required_input > fp_coins {
        return Err(ContractError::InsufficientFundsProvided(fp_coins, required_input));
    }

    current_balance = FPCoin {
        amount: required_input,  // Uses required_input for swap execution
        denom: source_denom.to_owned(),
    };

    // BUG: Refund calculated using estimation.result_quantity instead of required_input
    FPDecimal::from(coin_provided.amount) - estimation.result_quantity
} else {
    FPDecimal::ZERO
};
```

## ðŸ§  Root Cause

The root cause is a logic error where two different values are used:
1. **`required_input`**: The actual amount deducted from user funds and used for the swap (lines 69-73, 81-82)
2. **`estimation.result_quantity`**: The estimated amount used only for refund calculation (line 86)

When `is_input_quote` is true, the contract adds `FPDecimal::ONE` to create a buffer:
- `required_input = estimation.result_quantity + 1`
- But refund uses: `coin_provided.amount - estimation.result_quantity`

This means the refund is always 1 unit higher than it should be when using quote as input.

## âš ï¸ Exploitability

**Is this vulnerability exploitable?** **Yes**

### Attack Scenario 1: Direct Fund Theft (1 unit per transaction)

An attacker can repeatedly execute ExactOutput swaps where the first hop uses quote currency as input:

```rust
// Attack example:
// 1. User provides 1000 USDT for an ExactOutput swap
// 2. Estimation returns 999 USDT needed
// 3. Contract calculates:
//    - required_input = 999 + 1 = 1000 USDT (used for swap)
//    - refund = 1000 - 999 = 1 USDT (incorrect!)
// 4. User receives both:
//    - The exact output amount they requested
//    - An incorrect refund of 1 USDT
// 5. Net result: User steals 1 USDT from the contract
```

### Attack Scenario 2: Amplified Theft Through High-Frequency Trading

An attacker can automate this to drain contract funds:
- Execute hundreds of small ExactOutput swaps per block
- Each swap steals 1 unit of the quote currency
- Over time, this drains significant funds from the contract or other users

### Attack Scenario 3: Contract Insolvency

If the contract doesn't hold sufficient reserves:
- Multiple users executing legitimate swaps receive over-refunds
- Contract balance depletes
- Eventually, the contract cannot honor refunds, causing DoS

## ðŸ’¥ Impact

This vulnerability falls under **Critical** severity for smart contracts:
- **Direct theft of user funds**: Each ExactOutput swap can steal 1 unit of quote currency
- **Contract insolvency**: Over-refunds deplete contract reserves
- **Cascading failures**: Once insolvent, all subsequent swaps fail

The impact is particularly severe because:
1. It affects a core functionality (swapping)
2. Exploitation is trivial and can be automated
3. There's no user approval required for the theft
4. The stolen amount accumulates over multiple transactions

## âœ… Remediation Recommendations

### Immediate Fix
Replace the incorrect refund calculation with the correct one:

```rust
// Line 86 should be:
FPDecimal::from(coin_provided.amount) - required_input
```

### Complete Fixed Code
```rust
let refund_amount = if matches!(swap_quantity_mode, SwapQuantityMode::ExactOutputQuantity(..)) {
    let target_output_quantity = quantity;

    let estimation = estimate_swap_result(
        deps.as_ref(),
        &env,
        source_denom.to_owned(),
        target_denom,
        SwapQuantity::OutputQuantity(target_output_quantity),
    )?;

    let querier = InjectiveQuerier::new(&deps.querier);
    let first_market_id = steps[0].to_owned();
    let first_market = querier.query_spot_market(&first_market_id)?.market.expect("market should be available");

    let is_input_quote = first_market.quote_denom == *source_denom;

    let required_input = if is_input_quote {
        estimation.result_quantity.int() + FPDecimal::ONE
    } else {
        round_up_to_min_tick(estimation.result_quantity, first_market.min_quantity_tick_size)
    };

    let fp_coins: FPDecimal = coin_provided.amount.into();

    if required_input > fp_coins {
        return Err(ContractError::InsufficientFundsProvided(fp_coins, required_input));
    }

    current_balance = FPCoin {
        amount: required_input,
        denom: source_denom.to_owned(),
    };

    // FIXED: Use required_input for consistent refund calculation
    FPDecimal::from(coin_provided.amount) - required_input
} else {
    FPDecimal::ZERO
};
```

### Additional Safeguards

1. **Add invariant checks**:
```rust
debug_assert!(refund_amount >= FPDecimal::ZERO, "Refund cannot be negative");
debug_assert!(refund_amount < coin_provided.amount, "Refund cannot exceed input");
```

2. **Implement comprehensive logging**:
```rust
// Log all refund calculations for audit trail
let refund_event = Event::new("refund_calculated")
    .add_attribute("input_amount", coin_provided.amount.to_string())
    .add_attribute("required_input", required_input.to_string())
    .add_attribute("refund_amount", refund_amount.to_string());
```

## ðŸ” Related Issues

- **Rounding Inconsistency**: The same code section has inconsistent rounding between quote and base currencies
- **Missing Validation**: No checks ensure refund amounts are reasonable

## ðŸ§ª Test Cases

```rust
#[test]
fn test_exact_output_refund_calculation_quote_input() {
    // Setup: ExactOutput swap with quote as first hop input
    let mut deps = mock_dependencies();
    let env = mock_env();
    let info = mock_info("user", &coins(1000, "USDT"));
    
    // Configure swap: USDT -> INJ with exact output of 10 INJ
    let msg = ExecuteMsg::Swap {
        target_denom: "INJ".to_string(),
        swap_quantity_mode: SwapQuantityMode::ExactOutputQuantity(FPDecimal::from(10u128)),
    };
    
    // Mock estimation returns 999 USDT needed
    mock_estimate_swap_result(deps.as_mut(), FPDecimal::from(999u128));
    
    // Execute swap
    let res = execute(deps.as_mut(), env, info, msg).unwrap();
    
    // Verify refund message
    let refund_msg = res.messages.iter()
        .find(|m| matches!(m.msg, CosmosMsg::Bank(BankMsg::Send { .. })))
        .unwrap();
    
    match &refund_msg.msg {
        CosmosMsg::Bank(BankMsg::Send { amount, .. }) => {
            // Should refund 0 USDT (1000 provided - 1000 used)
            // But bug would refund 1 USDT (1000 provided - 999 estimation)
            assert_eq!(amount[0].amount, Uint128::zero());
        }
        _ => panic!("Expected bank send message"),
    }
}

#[test]
fn test_exact_output_refund_calculation_base_input() {
    // Test with base currency as input to verify different code path
    // Similar structure but with base currency
}

#[test]
fn test_refund_never_exceeds_input() {
    // Property test: refund + used_amount should always equal input
}
```