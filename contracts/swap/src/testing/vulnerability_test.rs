// Comprehensive Vulnerability Test for Global State Overwrite
// This test verifies if the reported vulnerability is actually exploitable in CosmWasm

#[cfg(test)]
mod vulnerability_tests {
    use cosmwasm_std::{
        testing::mock_dependencies,
        Addr, Coin,
    };
    use cw_storage_plus::Item;
    
    use crate::state::{SWAP_OPERATION_STATE};
    use crate::types::{CurrentSwapOperation, SwapQuantityMode};
    use injective_math::FPDecimal;
    use injective_cosmwasm::MarketId;

    /// Test 1: Verify that global state can be overwritten by concurrent operations
    #[test]
    fn test_global_state_overwrite_vulnerability() {
        let mut deps = mock_dependencies();

        // User A saves their swap state
        let user_a_state = CurrentSwapOperation {
            sender_address: Addr::unchecked("user_a"),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000001").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(100u128)),
            input_funds: Coin::new(10000_000000u128, "usdt"), // 10,000 USDT
            refund: Coin::new(0u128, "usdt"),
        };

        // Save User A's state to global storage
        SWAP_OPERATION_STATE.save(&mut deps.storage, &user_a_state).unwrap();

        // Verify User A's state is saved
        let loaded_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
        assert_eq!(loaded_state.sender_address, Addr::unchecked("user_a"));
        assert_eq!(loaded_state.input_funds.amount.u128(), 10000_000000);

        // User B starts their swap - THIS OVERWRITES USER A'S STATE
        let user_b_state = CurrentSwapOperation {
            sender_address: Addr::unchecked("user_b"),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000002").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(50u128)),
            input_funds: Coin::new(1_000000u128, "atom"), // 1 ATOM
            refund: Coin::new(0u128, "atom"),
        };

        // Save User B's state - overwrites User A completely
        SWAP_OPERATION_STATE.save(&mut deps.storage, &user_b_state).unwrap();

        // CRITICAL: User A's state is now completely lost
        let corrupted_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
        assert_eq!(corrupted_state.sender_address, Addr::unchecked("user_b")); // User A's address is gone!
        assert_eq!(corrupted_state.input_funds.denom, "atom"); // User A's USDT is gone!
        assert_eq!(corrupted_state.input_funds.amount.u128(), 1_000000); // User A's amount is gone!

        println!("VULNERABILITY CONFIRMED: Global state was overwritten!");
        println!("User A's 10,000 USDT state was replaced by User B's 1 ATOM state");
    }

    /// Test 2: Verify that there's no user isolation mechanism
    #[test]
    fn test_no_user_isolation() {
        let mut deps = mock_dependencies();

        // Try to save multiple users' states
        let users = vec!["alice", "bob", "charlie"];
        let mut last_saved_user = "";

        for user in users.iter() {
            let state = CurrentSwapOperation {
                sender_address: Addr::unchecked(*user),
                swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000003").unwrap()],
                swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(100u128)),
                input_funds: Coin::new(1000u128, "token"),
                refund: Coin::new(0u128, "token"),
            };

            SWAP_OPERATION_STATE.save(&mut deps.storage, &state).unwrap();
            last_saved_user = user;
        }

        // Only the last user's state remains
        let final_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
        assert_eq!(final_state.sender_address, Addr::unchecked(last_saved_user));

        println!("CONFIRMED: No user isolation - only one global state exists");
    }

    /// Test 3: Simulate the actual attack scenario
    #[test]
    fn test_attack_scenario_fund_theft() {
        let mut deps = mock_dependencies();

        // Step 1: Victim initiates large swap
        let victim_state = CurrentSwapOperation {
            sender_address: Addr::unchecked("victim_wallet"),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000004").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(1u128)),
            input_funds: Coin::new(1000000_000000u128, "usdt"), // 1 Million USDT
            refund: Coin::new(0u128, "usdt"),
        };

        SWAP_OPERATION_STATE.save(&mut deps.storage, &victim_state).unwrap();
        println!("Victim saved state with 1M USDT");

        // Step 2: Attacker quickly overwrites state
        let attacker_state = CurrentSwapOperation {
            sender_address: Addr::unchecked("attacker_wallet"),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000005").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(1u128)),
            input_funds: Coin::new(1_000000u128, "usdt"), // 1 USDT
            refund: Coin::new(0u128, "usdt"),
        };

        SWAP_OPERATION_STATE.save(&mut deps.storage, &attacker_state).unwrap();
        println!("Attacker overwrote state");

        // Step 3: When reply handler loads state, it gets attacker's address
        let loaded_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();

        // This is where funds would be sent in the real contract (swap.rs lines 229-230)
        let theft_target = loaded_state.sender_address.to_string();

        assert_eq!(theft_target, "attacker_wallet");
        println!("ATTACK SUCCESS: Funds would be sent to {}", theft_target);
        println!("Victim's address is completely lost from state");
    }

    /// Test 4: Verify CosmWasm's Item behavior
    #[test]
    fn test_cosmwasm_item_is_singleton() {
        let mut deps = mock_dependencies();

        // Items in CosmWasm are singletons - they store exactly one value
        let item: Item<String> = Item::new("test_item");

        item.save(&mut deps.storage, &"first_value".to_string()).unwrap();
        item.save(&mut deps.storage, &"second_value".to_string()).unwrap();

        // Only the second value exists
        let loaded = item.load(&deps.storage).unwrap();
        assert_eq!(loaded, "second_value");

        // There's no way to store multiple values with Item
        println!("CONFIRMED: CosmWasm Item is a singleton - only stores one value");
    }

    /// Test 5: Demonstrate what SHOULD be used instead (Map)
    #[test]
    fn test_proper_user_isolation_with_map() {
        use cw_storage_plus::Map;
        let mut deps = mock_dependencies();

        // This is what SHOULD be used for user-specific state
        let user_states: Map<Addr, CurrentSwapOperation> = Map::new("user_swap_states");

        // Save multiple users' states
        let user_a = Addr::unchecked("user_a");
        let user_b = Addr::unchecked("user_b");

        let state_a = CurrentSwapOperation {
            sender_address: user_a.clone(),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000006").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(100u128)),
            input_funds: Coin::new(10000u128, "usdt"),
            refund: Coin::new(0u128, "usdt"),
        };

        let state_b = CurrentSwapOperation {
            sender_address: user_b.clone(),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000007").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(50u128)),
            input_funds: Coin::new(5000u128, "atom"),
            refund: Coin::new(0u128, "atom"),
        };

        // Both states can coexist
        user_states.save(&mut deps.storage, user_a.clone(), &state_a).unwrap();
        user_states.save(&mut deps.storage, user_b.clone(), &state_b).unwrap();

        // Both states are preserved
        let loaded_a = user_states.load(&deps.storage, user_a).unwrap();
        let loaded_b = user_states.load(&deps.storage, user_b).unwrap();

        assert_eq!(loaded_a.input_funds.amount.u128(), 10000);
        assert_eq!(loaded_b.input_funds.amount.u128(), 5000);

        println!("SOLUTION: Using Map provides proper user isolation");
    }

    /// Test 6: Verify the reply_on_success vulnerability
    #[test]
    fn test_reply_on_success_leaves_dirty_state() {
        // In the actual contract, SubMsg::reply_on_success is used
        // This means if the SubMsg fails, the reply handler is NOT called
        // Therefore, state cleanup in the reply handler won't happen

        let mut deps = mock_dependencies();

        // Simulate a swap that will fail
        let state = CurrentSwapOperation {
            sender_address: Addr::unchecked("user"),
            swap_steps: vec![MarketId::new("0x0000000000000000000000000000000000000000000000000000000000000008").unwrap()],
            swap_quantity_mode: SwapQuantityMode::MinOutputQuantity(FPDecimal::from(100u128)),
            input_funds: Coin::new(10000u128, "usdt"),
            refund: Coin::new(0u128, "usdt"),
        };

        SWAP_OPERATION_STATE.save(&mut deps.storage, &state).unwrap();

        // Simulate SubMsg failure (reply handler NOT called with reply_on_success)
        // State remains in storage...

        // Next user's swap finds dirty state
        let dirty_state = SWAP_OPERATION_STATE.load(&deps.storage);
        assert!(dirty_state.is_ok());

        println!("CONFIRMED: reply_on_success leaves state dirty on failure");
        println!("Next user will inherit or overwrite this corrupted state");
    }
}