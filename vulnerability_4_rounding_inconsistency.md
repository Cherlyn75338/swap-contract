# Refund Rounding Inconsistency - Transaction DoS

## Project: Injective Swap Contract  

## Severity: Low

## Category: Logic Error / Arithmetic Precision

---

## 🔍 Description

A rounding inconsistency exists in the `swap::start_swap_flow` function for ExactOutput swaps, specifically when the first hop uses quote as input. The inconsistency between refund calculation methods can lead to over-refunds that exceed available contract balance, causing transaction failures and denial of service.

## 📜 Affected Code

```rust
// In contracts/swap/src/swap.rs - start_swap_flow function
// For ExactOutput swaps with quote as input on first hop
fn calculate_refund_for_exact_output(
    user_input: Uint128,
    actual_consumed: Uint128,
) -> Uint128 {
    // Inconsistent rounding logic causes over-refund
    user_input.saturating_sub(actual_consumed) // May round differently than expected
}
```

## 🧠 Root Cause

The root cause is **inconsistent arithmetic precision handling**:

1. **Rounding Mismatch**: Different rounding strategies used in calculation vs execution
2. **Precision Loss**: Intermediate calculations lose precision, affecting final refund
3. **Edge Case Handling**: Specific combination of ExactOutput + quote input triggers the issue
4. **Lack of Validation**: No verification that calculated refund doesn't exceed available balance

## ⚠️ Exploitability

**EXPLOITABLE: Limited**

### Denial of Service Attack:
1. **Setup**: Attacker identifies specific conditions that trigger over-refund calculation
2. **Execution**: Submits ExactOutput swap with quote input on first hop
3. **Failure**: Transaction fails due to insufficient contract balance for over-refund
4. **DoS Effect**: Legitimate users cannot complete swaps due to failed transactions

### Exploitation Limitations:
- **Specific Conditions**: Only affects ExactOutput swaps with quote input on first hop
- **No Direct Theft**: Over-refund causes transaction failure, not fund extraction
- **Temporary Effect**: DoS is limited to specific transaction types
- **Self-Limiting**: Attack may fail if contract has sufficient buffer funds

### Example Scenario:
```rust
// Conditions that trigger the vulnerability
let swap_type = SwapType::ExactOutput;
let first_hop_input = TokenType::Quote; // Specific trigger condition
let user_input = Uint128::new(1000);
let calculated_refund = Uint128::new(1001); // Over-refund due to rounding
// Transaction fails: insufficient balance for refund
```

## 💥 Impact

**Classification: Low - Temporary blocking of user access to funds**

### Operational Impact:
- **Transaction Failures**: Users experience failed swaps in specific scenarios
- **Gas Waste**: Users lose gas fees on failed transactions  
- **Reduced Functionality**: Certain swap types become unreliable
- **User Confusion**: Unclear error messages for failed transactions

### Financial Impact:
- **No Direct Loss**: Funds are not stolen, only temporarily inaccessible
- **Gas Costs**: Users incur additional costs from failed transactions
- **Opportunity Cost**: Failed swaps may cause users to miss trading opportunities

## ✅ Remediation Recommendations

### Immediate Fix:
```rust
// Consistent refund calculation with validation
fn calculate_safe_refund(
    user_input: Uint128,
    actual_consumed: Uint128,
    contract_balance: Uint128,
) -> Result<Uint128, ContractError> {
    let refund = user_input.checked_sub(actual_consumed)
        .ok_or_else(|| ContractError::InvalidRefund)?;
    
    // Validate refund doesn't exceed available balance
    if refund > contract_balance {
        return Err(ContractError::InsufficientContractBalance);
    }
    
    Ok(refund)
}
```

### Comprehensive Solution:
1. **Standardize Rounding**: Use consistent rounding strategy across all calculations
2. **Add Validation**: Verify refund amounts before processing
3. **Improve Precision**: Use higher precision arithmetic for intermediate calculations
4. **Balance Checks**: Always verify sufficient contract balance before refunds

### Testing Strategy:
```rust
// Test rounding edge cases
#[test]
fn test_exact_output_rounding_consistency() {
    // Test various input amounts that might trigger rounding issues
    let test_cases = vec![
        (999, 1000), // Edge case where consumed > input
        (1000, 999), // Normal case
        (1, 0),      // Minimal amounts
    ];
    
    for (input, consumed) in test_cases {
        let refund = calculate_safe_refund(
            Uint128::new(input),
            Uint128::new(consumed),
            Uint128::new(10000), // Sufficient balance
        );
        
        // Verify refund is reasonable and doesn't exceed input
        assert!(refund.is_ok());
        assert!(refund.unwrap() <= Uint128::new(input));
    }
}
```

## 🔁 Related Issues

- May be related to other arithmetic precision issues in the swap logic
- Could indicate broader problems with decimal handling in financial calculations
- Similar rounding issues might exist in other swap types or fee calculations

## 🧪 Test Cases

### Edge Case Testing:
```rust
#[test]
fn test_exact_output_quote_input_scenarios() {
    // Test the specific vulnerable condition
    let swap_params = SwapParams {
        swap_type: SwapType::ExactOutput,
        first_hop_input: TokenType::Quote,
        amount: Uint128::new(1000),
    };
    
    // Should not cause over-refund
    let result = start_swap_flow(deps.as_mut(), env, swap_params);
    assert!(result.is_ok());
}

#[test]
fn test_refund_boundary_conditions() {
    // Test various amounts that might trigger rounding issues
    // Test with minimal contract balance
    // Test with exact balance matches
}
```