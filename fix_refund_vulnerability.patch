diff --git a/contracts/swap/src/swap.rs b/contracts/swap/src/swap.rs
index abcdef1..1234567 100644
--- a/contracts/swap/src/swap.rs
+++ b/contracts/swap/src/swap.rs
@@ -83,7 +83,11 @@ pub fn start_swap_flow(
             denom: source_denom.to_owned(),
         };
 
-        FPDecimal::from(coin_provided.amount) - estimation.result_quantity
+        // FIX: Use required_input instead of estimation.result_quantity for refund calculation
+        // This ensures the refund matches the actual amount that will be used in the swap
+        FPDecimal::from(coin_provided.amount)
+            .checked_sub(required_input)
+            .ok_or_else(|| ContractError::InsufficientFundsProvided(fp_coins, required_input))?
     } else {
         FPDecimal::ZERO
     };
@@ -66,10 +66,17 @@ pub fn start_swap_flow(
 
         let is_input_quote = first_market.quote_denom == *source_denom;
 
+        // TODO: Investigate why FPDecimal::ONE is added and consider using proper slippage handling
         let required_input = if is_input_quote {
-            estimation.result_quantity.int() + FPDecimal::ONE
+            // Adding buffer for quote input to ensure sufficient funds
+            // This should be replaced with proper slippage tolerance
+            let buffer = FPDecimal::must_from_str("0.001"); // 0.1% buffer instead of arbitrary 1 unit
+            let buffered_amount = estimation.result_quantity * (FPDecimal::ONE + buffer);
+            buffered_amount.int()
         } else {
+            // For base input, round up to minimum tick size
             round_up_to_min_tick(estimation.result_quantity, first_market.min_quantity_tick_size)
         };
 
+        // Add validation to ensure refund is non-negative
+        if required_input > FPDecimal::from(coin_provided.amount) {
+            return Err(ContractError::InsufficientFundsProvided(fp_coins, required_input));
+        }