### Critique of “100% Exploitable” Analysis — Injective Swap Contract

Scope: `contracts/swap` (current repo state)
Purpose: Line-by-line verification of asserted exploits against actual code and CosmWasm semantics
Verdict: The asserted exploits are NOT reachable in this implementation

---

## 1) Claim: “Global singleton overwrite → funds sent to attacker” (100% exploitable)

- Assertion depends on another transaction overwriting `SWAP_OPERATION_STATE` between an execute() and its reply().
- In this code, the singleton is written, a SubMsg with `reply_on_success` is dispatched, the reply runs in the SAME transaction, then state is cleared.
- No other user transaction can interleave between the write and read within the same tx.

Code evidence:
```startLine:91:endLine:105:/workspace/contracts/swap/src/swap.rs
SWAP_RESULTS.save(deps.storage, &Vec::new())?;
SWAP_OPERATION_STATE.save(deps.storage, &swap_operation)?;
execute_swap_step(deps, env, swap_operation, 0, current_balance).map_err(ContractError::Std)
```
```startLine:144:endLine:156:/workspace/contracts/swap/src/swap.rs
let order_message = SubMsg::reply_on_success(..., ATOMIC_ORDER_REPLY_ID);
STEP_STATE.save(deps.storage, &current_step)?;
let response = Response::new().add_submessage(order_message);
Ok(response)
```
```startLine:158:endLine:176:/workspace/contracts/swap/src/swap.rs
pub fn handle_atomic_order_reply(..., msg: Reply) -> Result<...> {
  let swap = SWAP_OPERATION_STATE.load(deps.storage)?;
  // ... compute next or finalize
```
```startLine:227:endLine:245:/workspace/contracts/swap/src/swap.rs
let send_message = BankMsg::Send { to_address: swap.sender_address.to_string(), amount: vec![new_balance.clone().into()] };
SWAP_OPERATION_STATE.remove(deps.storage);
STEP_STATE.remove(deps.storage);
SWAP_RESULTS.remove(deps.storage);
```
Conclusion: Not exploitable here. The reply consumes and clears state atomically in the same tx.

---

## 2) Claim: “SubMsg failure leaves dirty state that persists” (100% exploitable)

- With `reply_on_success`, if the submessage fails, the reply is not invoked and the entire contract execution fails.
- CosmWasm commits storage writes only if the message succeeds. Thus, prior `save()` calls are rolled back if the submessage fails.

Code/semantics:
```startLine:144:endLine:146:/workspace/contracts/swap/src/swap.rs
let order_message = SubMsg::reply_on_success(..., ATOMIC_ORDER_REPLY_ID);
```
- Failure → no reply → execute returns error → whole tx reverts → no dirty state.
Conclusion: Not exploitable here.

---

## 3) Claim: “Race/MEV across users overwrites victim state before their reply” (100% exploitable)

- MEV can reorder different transactions, but cannot interleave within a single transaction.
- The critical read of `SWAP_OPERATION_STATE` occurs in the same transaction that wrote it; no cross-tx window is left open.

Evidence: same citations as Sections 1 and 2.
Conclusion: Not exploitable here.

---

## 4) Claim: “Multi-step swap state corruption between steps” (100% exploitable)

- Steps are chained by sending another SubMsg from within the reply handler (still inside the same tx).
- There is no user-facing second transaction to continue steps; state is cleared at finalization.

Evidence:
```startLine:213:endLine:216:/workspace/contracts/swap/src/swap.rs
if current_step.step_idx < (swap.swap_steps.len() - 1) as u16 {
  SWAP_RESULTS.save(deps.storage, &swap_results)?;
  return execute_swap_step(deps, env, swap, current_step.step_idx + 1, new_balance).map_err(ContractError::Std);
}
```
Conclusion: Not exploitable here.

---

## 5) Claim: “IBC async callbacks / sudo callbacks / WasmMsg reentrancy facilitate overwrite”

- Repository contains no IBC entrypoints, no `sudo`, and no `WasmMsg::Execute` to untrusted contracts in the swap flow.

Evidence:
```startLine:68:endLine:74:/workspace/contracts/swap/src/contract.rs
pub fn reply(..., msg: Reply) -> Result<...> {
  match msg.id {
    ATOMIC_ORDER_REPLY_ID => handle_atomic_order_reply(...),
    _ => Err(ContractError::UnrecognizedReply(msg.id)),
  }
}
```
- No `ibc_*` or `sudo` functions exist anywhere; external call is Injective custom message handled in the same tx.
Conclusion: Not applicable.

---

## Clarification on CosmWasm Semantics (why the claims don’t hold here)

- Atomicity applies to the entire execute → submsg(s) → reply flow inside one transaction. If any submessage fails, the tx fails; no writes persist.
- Transaction ordering (MEV) cannot split a single transaction; it affects ordering across transactions only. This contract does not leave singleton state resident awaiting future transactions.

---

## Final Answers (Definitive)

- Is this a real vulnerability here? No — intended pattern: singleton used only within one atomic tx; state cleared.
- Is it 100% exploitable on-chain? No.
- Prerequisites/permissions? N/A.
- Financial impact? None under current code.
- Conditions to work/fail? Would require adding async handlers or external Wasm calls; otherwise fails.
- Existing mitigations? Effective by design (atomic flow, cleanup, no async/sudo/WasmMsg, revert on failure).
- Achievable under actual protocol conditions? No.

---

## Recommendation

- If future changes add IBC/sudo async callbacks or external Wasm calls, replace singletons with keyed `Map<K,V>` and correlate by operation ID; verify ownership; consider reentrancy guards. Today, not required to prevent the asserted exploits.