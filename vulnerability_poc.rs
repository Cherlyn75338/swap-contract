use injective_math::FPDecimal;
use std::str::FromStr;

// This is a simplified demonstration of the vulnerability
// In the actual contract, this logic is in start_swap_flow() lines 52-89

fn demonstrate_over_refund_vulnerability() {
    println!("🔍 Demonstrating SwapExactOutput Over-Refund Vulnerability");
    
    // Simulate the scenario where source denom is base currency (is_input_quote = false)
    let is_input_quote = false;
    
    // User provides this amount
    let coin_provided_amount = FPDecimal::from_str("1000000").unwrap(); // 1M units
    
    // Estimation result from estimate_swap_result (E)
    let estimation_result_quantity = FPDecimal::from_str("999999.5").unwrap(); // 999999.5 units
    
    // Required input calculation (R) - this is the critical part
    let required_input = if is_input_quote {
        estimation_result_quantity.int() + FPDecimal::ONE
    } else {
        // For base currency, round up to min tick
        let min_quantity_tick_size = FPDecimal::from_str("1.0").unwrap();
        round_up_to_min_tick(estimation_result_quantity, min_quantity_tick_size)
    };
    
    println!("💰 User provided: {}", coin_provided_amount);
    println!("📊 Estimation result (E): {}", estimation_result_quantity);
    println("🔢 Required input (R): {}", required_input);
    
    // The refund calculation - THIS IS THE VULNERABILITY
    let refund_amount = coin_provided_amount - estimation_result_quantity; // Uses E, not R!
    
    println!("💸 Refund calculated: {}", refund_amount);
    
    // What actually happens in the contract:
    // 1. Contract uses required_input (R) for the swap
    // 2. Contract refunds based on estimation_result_quantity (E)
    // 3. Over-refund = R - E
    
    let actual_used_amount = required_input;
    let actual_unused_amount = coin_provided_amount - actual_used_amount;
    let over_refund = refund_amount - actual_unused_amount;
    
    println!("⚠️  Actual amount used in swap: {}", actual_used_amount);
    println!("✅ Actual unused amount: {}", actual_unused_amount);
    println!("🚨 Over-refund (vulnerability): {}", over_refund);
    
    if over_refund > FPDecimal::ZERO {
        println!("💥 VULNERABILITY CONFIRMED: Contract over-refunds by {} units", over_refund);
        println!("🔄 This can be repeated to drain contract funds systematically");
    }
}

// Helper function from helpers.rs
fn round_up_to_min_tick(num: FPDecimal, min_tick: FPDecimal) -> FPDecimal {
    if num < min_tick {
        return min_tick;
    }

    let remainder = FPDecimal::from(num.num % min_tick.num);

    if remainder.num.is_zero() {
        return num;
    }

    FPDecimal::from(num.num - remainder.num + min_tick.num)
}

fn main() {
    demonstrate_over_refund_vulnerability();
}