### Injective Swap Contract – Definitive Exploit Verification (CosmWasm Semantics Applied)

- Scope: `contracts/swap` (current codebase)
- Objective: 100% verification of exploitability under CosmWasm semantics (semantics, actor-model, transactions, execute/reply)
- Method: Line-by-line dissection, control/data flow mapping, exploit path confirmation/refutation, mitigations

---

## Phase 1: Line-by-Line Technical Dissection

### Storage Layout and Access

- Definitions:
```startLine:6:endLine:12:/workspace/contracts/swap/src/state.rs
pub const SWAP_ROUTES: Map<(String, String), SwapRoute> = Map::new("swap_routes");
pub const SWAP_OPERATION_STATE: Item<CurrentSwapOperation> = Item::new("current_swap_cache");
pub const STEP_STATE: Item<CurrentSwapStep> = Item::new("current_step_cache");
pub const SWAP_RESULTS: Item<Vec<SwapResults>> = Item::new("swap_results");
pub const CONFIG: Item<Config> = Item::new("config");
```
- Observations:
  - `SWAP_OPERATION_STATE`, `STEP_STATE`, `SWAP_RESULTS` are singletons.
  - These are only written inside the swap execute path and cleared at the end of the same atomic flow.

### Entry Points and Control Flow

- Entry points implemented:
```startLine:21:endLine:31:/workspace/contracts/swap/src/contract.rs
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(...)
```
```startLine:34:endLine:66:/workspace/contracts/swap/src/contract.rs
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(..., msg: ExecuteMsg) -> Result<Response<InjectiveMsgWrapper>, ContractError> {
    match msg {
        ExecuteMsg::SwapMinOutput { .. } => start_swap_flow(...),
        ExecuteMsg::SwapExactOutput { .. } => start_swap_flow(...),
        // admin fns elided
    }
}
```
```startLine:68:endLine:74:/workspace/contracts/swap/src/contract.rs
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn reply(deps: DepsMut<InjectiveQueryWrapper>, env: Env, msg: Reply) -> Result<Response<InjectiveMsgWrapper>, ContractError> {
    match msg.id {
        ATOMIC_ORDER_REPLY_ID => handle_atomic_order_reply(deps, env, msg),
        _ => Err(ContractError::UnrecognizedReply(msg.id)),
    }
}
```
- Not present anywhere:
  - Any `ibc_*` entrypoints.
  - Any `sudo` entrypoint.
  - Any `WasmMsg::Execute` to external Wasm contracts in the swap flow.

### Swap Execution Path

1) Start of flow – writes state, then issues SubMsg with `reply_on_success`:
```startLine:91:endLine:105:/workspace/contracts/swap/src/swap.rs
let swap_operation = CurrentSwapOperation { /* sender, steps, mode, refund, input */ };
SWAP_RESULTS.save(deps.storage, &Vec::new())?;
SWAP_OPERATION_STATE.save(deps.storage, &swap_operation)?;
execute_swap_step(deps, env, swap_operation, 0, current_balance).map_err(ContractError::Std)
```
```startLine:144:endLine:152:/workspace/contracts/swap/src/swap.rs
let order_message = SubMsg::reply_on_success(
    create_spot_market_order_msg(contract.to_owned(), order),
    ATOMIC_ORDER_REPLY_ID,
);
let current_step = CurrentSwapStep { step_idx, current_balance, step_target_denom: estimation.result_denom, is_buy: estimation.is_buy_order };
STEP_STATE.save(deps.storage, &current_step)?;
```
2) Reply handler – executes within the same transaction, reads state, computes, and may recurse next step or finalize:
```startLine:158:endLine:176:/workspace/contracts/swap/src/swap.rs
pub fn handle_atomic_order_reply(..., msg: Reply) -> Result<Response<InjectiveMsgWrapper>, ContractError> {
    let order_response = parse_market_order_response(msg)?;
    // parse and scale values
    let mut swap_results = SWAP_RESULTS.load(deps.storage)?;
    let current_step = STEP_STATE.load(deps.storage).map_err(ContractError::Std)?;
    let swap = SWAP_OPERATION_STATE.load(deps.storage)?;
```
3) Finalization – sends funds to original `sender_address` and removes all singleton state:
```startLine:227:endLine:245:/workspace/contracts/swap/src/swap.rs
let send_message = BankMsg::Send { to_address: swap.sender_address.to_string(), amount: vec![new_balance.clone().into()] };
...
SWAP_OPERATION_STATE.remove(deps.storage);
STEP_STATE.remove(deps.storage);
SWAP_RESULTS.remove(deps.storage);
```

### Traits, Macros, and Access Control

- Traits/Macros: Standard derives on types (not shown here). No unsafe blocks detected. No custom procedural macros altering storage behavior.
- Access control:
  - Admin-only paths are enforced in `admin.rs` via `verify_sender_is_admin` and used only for route/config; not part of swap payout path.
  - Swap path uses `MessageInfo.sender` as payout target, captured at start.

---

## Phase 2: Exploit Path Confirmation (Definitive)

We evaluate each claimed vector against actual code and CosmWasm semantics (atomicity within a transaction, reply as part of same tx, serial transaction processing without interleaving inside one tx).

1) Global Singleton Overwrite → “Funds to attacker”
- Claim requires: Another transaction interleaves between `execute()` and its `reply()` to overwrite `SWAP_OPERATION_STATE` before the reply reads it.
- Reality: The reply here is generated by `SubMsg::reply_on_success` and executes inside the SAME transaction. No other transaction can execute between the submessage dispatch and the reply handler of that same transaction. Therefore, a different user’s transaction cannot overwrite `SWAP_OPERATION_STATE` in between.
- Additionally, on finalization the contract removes the singleton state.
- Verdict: NOT EXPLOITABLE in this codebase.

2) SubMsg Failure State Persistence
- With `reply_on_success`, if the submessage fails, the runtime does not call `reply`; the failure bubbles up and the entire outer execute fails, rolling back all writes in this transaction (including earlier `SWAP_OPERATION_STATE.save(...)`).
- There is no alternative code path that commits partial state on submessage failure.
- Verdict: NOT EXPLOITABLE (no dirty state persists on submsg failure).

3) Race Condition / MEV (cross-transaction ordering)
- Different users’ transactions can be ordered arbitrarily across blocks, but cannot interleave inside a single transaction’s execute+reply flow. This contract’s critical read of the singleton occurs in the reply of the SAME transaction that wrote it.
- There is no multi-transaction stepper or async callback that leaves singleton state resident awaiting a later tx.
- Verdict: NOT EXPLOITABLE here.

4) IBC async callbacks (ibc_packet_ack)
- No IBC entrypoints exist; thus no async cross-block callback uses singleton state.
- Verdict: NOT APPLICABLE.

5) Sudo callbacks
- No `sudo` entrypoint exists; exchange interaction is via custom message + reply in same tx.
- Verdict: NOT APPLICABLE.

6) WasmMsg Reentrancy
- No `WasmMsg::Execute` to untrusted contracts in swap flow; no cross-contract reentrancy surface.
- Verdict: NOT APPLICABLE.

---

## Phase 3: Mitigation & Countermeasure Analysis

Existing mitigations (by design):
- Single-transaction atomic swap flow via `reply_on_success` submessage pattern.
- State is cleared (`remove`) immediately after final payout.
- No async IBC/sudo or external Wasm calls.
- Failure of submessage causes entire tx to revert (no state persistence).

Effectiveness: High in this codebase; prevents the reported singleton overwrite exploit from being reachable.

Recommendations (future-proofing ONLY if new async/external flows are added):
- Replace singleton user operation state with `Map<K,V>` keyed by operation ID or sender.
- Correlate callbacks by ID, verify ownership in any async handler.
- Add reentrancy guards if introducing external Wasm calls.

---

## Final Answers (Yes/No)

- Is this a real vulnerability, or intended behavior? → Intended behavior here. Not a vulnerability as implemented.
- Is it 100% exploitable on-chain? → No.
- Actor prerequisites? → N/A (no reachable path).
- Financial impact? → None under current design.
- Conditions to work/fail? → Would require adding async or external reentrancy surfaces; otherwise fails.
- Existing mitigations? → Effective by design (atomic execute+reply, cleanup, no async/external calls).
- Achievable under protocol conditions? → No; only contrived storage overwrites outside the transaction model.